#! /usr/bin/env bash

# SPDX-License-Identifier: MIT

########################################################################
#                                                                      #
#  This file is part of collection of scripts for working with keys    #
#  and certificates using GnuPG.                                       #
#                                                                      #
#  Copyright Â© 2020  Chindraba (Ronald Lamoreaux)                      #
#                    <aoc@chindraba.work>                              #
#  - All Rights Reserved                                               #
#                                                                      #
#  Permission is hereby granted, free of charge, to any person         #
#  obtaining a copy of this software and associated documentation      #
#  files (the "Software"), to deal in the Software without             #
#  restriction, including without limitation the rights to use, copy,  #
#  modify, merge, publish, distribute, sublicense, and/or sell copies  #
#  of the Software, and to permit persons to whom the Software is      #
#  furnished to do so, subject to the following conditions:            #
#                                                                      #
#  The above copyright notice and this permission notice shall be      #
#  included in all copies or substantial portions of the Software.     #
#                                                                      #
#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,     #
#  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  #
#  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND               #
#  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS #
#  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  #
#  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN   #
#  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE    #
#  SOFTWARE.                                                           #
#                                                                      #
########################################################################

source ./.config

auth_filter='a'
crypt_filter='e'
sign_filter='s'
ecc_filter='..25519'
rsa_filter=':23'
sub_filter='^ssb'
sec_filter='^sec'

# Routine for error condition messages and aborting.
report_error() {
# Arg: message to display
# Return: terminate program/subshell
# Exitcode: 1
    printf "\nERROR: %s Aborting.\n" "$1" >&2
    exit 1
}

# Routine for reporting that there is nothing to do, for whatever reason
report_nothing() {
# Arg: message to display
# Return: terminate program/subshell
# Exitcode: 1
    printf "\n%s Nothing to do.\n" "$1" >&2
    exit 1
}

# Routine to convert a ring_name to a path
get_ring_path() {
# Arg: Name of the keyring, established in the keyring_list file
# Return: Filesystem path for the keyring
# Exitcode: T/F valid/invalid path
    [ -z $1 ] && \
        report_nothing "No keyring name supplied."
    ring_var="ring_${1,,}"
    [ -d "${!ring_var}" ] || \
        report_error "Invalid keyring name $1."
    printf "%s" "${!ring_var}"
}

# Routine to load cert config data
check_config_data() {
# Arg: Config file basename, case insensitive
# Return: Filesystem path the usable certificate config file
# Exitcode: T/F valid/invalid path
    [ -z $1 ] && \
        report_nothing "No config file given."
    [ -e "$config_dir/${1^^}.cfg" ] || \
        report_error "Config file for '$1' not found."
    printf "%s" "$config_dir/${1^^}.cfg"
}

# Routine to check a passphrase against a certificate
check_pass() {
# Args: keyring path
#       certificate ID
#       passphrase to test
# Return: none
# Exitcode: T/F valid/invalid passphrase
    printf "%s" "$3" \
    | gpg \
        --homedir $1 \
        --batch \
        --yes \
        --expert \
        --pinentry-mode loopback \
        --passphrase-fd 0 \
        --export-secret-key "${2// /}" \
    >/dev/null 2>/dev/null
}

# Routine to find the valid passpharse for a certificate
find_pass() {
# Args: Keyring path
#       certificate ID
# Return: Found passphrase in $good_pass
# Exitcode: 0 (terminates on error)
    good_pass=''
    for test_pass in $pass_list; do
        check_pass "$1" "$2" "$test_pass"
        [ 0 -eq $? ] && \
            good_pass="$test_pass"
    done
    [ -z "$good_pass" ] && \
        report_error "No known passphrase works on cert ID: '$2'."
}

# Change the passpharse on a certificate
new_pass() {
# Args: Keyring path
#       certificate ID
#       current passphrase
#       new passphrase
# Return: nothing
# Exitcode: 0 (terminates on error)
    checking="$(\
        printf "%s\n%s\n%s\n" "$3" "$4" "$4" \
        | gpg \
            --homedir $1 \
            --batch \
            --yes \
            --expert \
            --pinentry-mode loopback \
            --command-fd 0 --passwd "${2// /}" \
        2>/dev/null\
    )"
    [ 0 -eq $? ] || \
        report_error "Changing passphrase on ${2// /} failed."
}

# Routine to check the given keyring for the selected cert
check_prime() {
# Args: Keyring path
#       certificate ID
# Retrun: verified certificate ID
# Exitcode: 0 (terminates on error)
    find_id="${2// /}"
    test_id="$(\
        gpg \
            --homedir "$1" \
            --with-colons \
            --list-secret-keys $find_id \
        2>/dev/null \
        | grep -A 1 ^sec \
        | tail -n 1 \
        | awk -F : -e '{printf $10}'\
    )"
    [ 0 -eq $? ] || \
        report_error "Searching keyring $1 for cert id '$2' failed."
    [ "$test_id" == "$find_id" ] || \
        report_error "Searching for $find_id in keyring $1 returned $test_id. Mismatched ID's."
    printf "%s" $test_id
}
