#! /usr/bin/env bash

# SPDX-License-Identifier: MIT

########################################################################
#                                                                      #
#  This file is part of collection of scripts for working with keys    #
#  and certificates using GnuPG.                                       #
#                                                                      #
#  Copyright Â© 2020  Chindraba (Ronald Lamoreaux)                      #
#                    <aoc@chindraba.work>                              #
#  - All Rights Reserved                                               #
#                                                                      #
#  Permission is hereby granted, free of charge, to any person         #
#  obtaining a copy of this software and associated documentation      #
#  files (the "Software"), to deal in the Software without             #
#  restriction, including without limitation the rights to use, copy,  #
#  modify, merge, publish, distribute, sublicense, and/or sell copies  #
#  of the Software, and to permit persons to whom the Software is      #
#  furnished to do so, subject to the following conditions:            #
#                                                                      #
#  The above copyright notice and this permission notice shall be      #
#  included in all copies or substantial portions of the Software.     #
#                                                                      #
#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,     #
#  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  #
#  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND               #
#  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS #
#  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  #
#  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN   #
#  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE    #
#  SOFTWARE.                                                           #
#                                                                      #
########################################################################

set -o pipefail

source ./_helpers

# Extract a key, or cert, from the keyring
extract_key() { # keyring_path data_pfx algo target_id save_path [('asc')|'gpg' [('key')|'cert [('pub')|'sec' [pass]]]]
    key_name="${2^^}_user"
    pfx_name="${2^^}_pfx"
    file_pfx="${!pfx_name}"
    [ -d "$5" ] || mkdir -p "$5" 2>/dev/null
    [ 0 -eq $? ] || \
        report_error "Destination path '$5' not available."
    if [ 'gpg' == "${6,,}" ]; then
        armor=''
        format='GPG'
    else
        armor='--armor'
        format='ASC'
    fi
    if [ 'cert' == "${7,,}" ]; then
        target=$4
        file_label='cert'
        note_label='certificate'
    else
        target="$4!"
        file_label=$(echo $7|awk -e '{printf $2"."$1}')
        note_label="$7"
    fi
    if [ 'sec' == "${8,,}" ]; then
        export_type='-secret-key'
        note_type='secret'
        export_label='sec'
    else
        export_type=''
        note_type='public'
        export_label='pub'
    fi
    [ -z "$9" ] && pass='' || pass="$9"
    file_note="${3^^} $note_type $note_label for ${!key_name}"
    printf "Saving %s in %s format ... " "$file_note" $format
    printf "%s" "$pass" |
    gpg \
        --homedir $1 \
        --batch \
        --yes \
        --expert \
        --pinentry-mode loopback \
        --passphrase-fd 0 \
        --output "$5/${!pfx_name}.${3,,}.$file_label.$export_label.${format,,}" \
        --comment "$file_note" $armor \
        --export$export_type $target 2>/dev/null
    [ 0 == $? ] || \
        report_error "Saving of $file_note in $format format failed."
    printf " DONE \n"
}

# Routine to extract the auth public key in openSSH format
extract_ssh_key() {
    pfx_name="${2^^}_pfx"
    key_uid="${2^^}_primary_uid"
    algo_flag="${3,,}_filter"
    var_name="${5}_filter"
    purpose_flag="${!var_name}"
    key_grip="$(\
        gpg \
            --homedir $1 \
            --with-colons \
            --batch \
            --expert \
            --list-secret-keys $4 2>/dev/null | \
            grep -A 2 "ssb:.*:${purpose_flag}:::::${!algo_flag}" | \
            tail -n 1 | \
            awk -F : -e '{printf $10"\n"}' \
    )"
    [ 0 -eq $? ] || \
        report_error "Unable to get the key grip for [${purpose_flag}] from ${2^^} in $1."
    ssh_key="$(\
        gpg \
            --homedir $1 \
            --batch \
            --expert \
            --export-ssh-key $purpose_key! 2>/dev/null\
    )"
    [ 0 -eq $? ] || \
        report_error "Unable to get the SSH key for ${2^^}."
    printf "%s\n" "$ssh_key" > "$export_dir/${!pfx_name}.${3,,}.key.ssh.${3,,}.pub"
    [ 0 == $? ] || \
        report_error "Writing of SSH pub file failed."
    printf "%s\n# %s\n# %s\n" "$key_grip" "${!key_uid}" "$ssh_key" > "$export_dir/${!pfx_name}.${3,,}.key.ssh.${3,,}.sshcontrol"
    [ 0 == $? ] || \
        report_error "Writing of sshcontrol file for ${2^^} failed."
}

# Extract public and secret, primary and sub keys to files
store_cert() { # keyring_path data_pfx target_algo
    id_name="${2^^}_${3,,}_sec"
    target_id="$(
        check_prime "$1" "${!id_name}"
    )"
    good_pass="${pass_main}"
    printf "Checking for a known passphrase for the ${2^^} ${3^^} cert."
    check_pass "$1" "$target_id" "$good_pass"
    [ 0 -eq $? ] || \
        find_pass "$1" "$target_id"
    # Save the primary key to files
    store_prime "$1" "${2^^}" "${3,,}" "$target_id"
    # Need to have the subkeys stored with a different passpharse than the master
    new_pass "$1" "$target_id" "$good_pass" "${pass_base}${2^^}"
    for purpose in sign crypt auth; do
        # Save the subkeys to files
        store_subkey "$1" "$2" "$3" "$target_id" "$purpose"
    done
    # Reverse the passphrase change
    new_pass "$1" "$target_id" "${pass_base}${2^^}" "$good_pass"
}

# Routine to walk through the ECC and RSA pair of certs
store_cert_pair() {
    keyring_path="$(get_ring_path $1)"
    [ 0 -eq $? ] || exit 1
    data_file="$(check_config_data $2)"
    [ 0 -eq $? ] || exit 1
    source "$data_file"
    for target_algo in ecc rsa; do
        store_cert "$keyring_path" "${2^^}" $target_algo
    done
}

# Extract the primary key to files for storage
store_prime() {
    # save the primary public key
    extract_key "$1" "${2,,}" "$3" "${4// /}" "$export_dir" 'asc' 'primary key' 'pub'
    # save the full public cert
    extract_key "$1" "${2,,}" "$3" "${4// /}" "$export_dir" 'asc' 'cert' 'pub'
    # save the full secret cert
    extract_key "$1" "${2,,}" "$3" "${4// /}" "$extract_dir" 'gpg' 'cert' 'sec' "$good_pass"
    # change the passphrase for backup files
    new_pass "$1" "${4// /}" "$good_pass" "${prime_base}${pass_base}${2^^}"
    # save the primary secret key and full secret cert in asc and gpg formats
    extract_key "$1" "${2,,}" "$3" "${4// /}" "$import_dir" 'asc' 'primary key' 'sec' "${prime_base}${pass_base}${2^^}"
    extract_key "$1" "${2,,}" "$3" "${4// /}" "$import_dir" 'asc' 'cert' 'sec' "${prime_base}${pass_base}${2^^}"
    extract_key "$1" "${2,,}" "$3" "${4// /}" "$import_dir" 'gpg' 'primary key' 'sec' "${prime_base}${pass_base}${2^^}"
    extract_key "$1" "${2,,}" "$3" "${4// /}" "$import_dir" 'gpg' 'cert' 'sec' "${prime_base}${pass_base}${2^^}"
    # reset the passphrase from above
    new_pass "$1" "${4// /}" "${prime_base}${pass_base}${2^^}" "$good_pass"
}

# Extract the secret and public, and possibly SSH sub keys to files
store_subkey() { # keyring_path data_pfx algo cert_id purpose
    algo_flag="${3,,}_filter"
    var_name="${5}_filter"
    purpose_flag="${!var_name}"
    purpose_key="$(\
        gpg \
            --homedir $1 \
            --with-colons \
            --batch \
            --expert \
            --list-secret-keys $4 2>/dev/null | \
            grep -A 1 "ssb:.*:${purpose_flag}:::::${!algo_flag}" | \
            tail -n 1 | \
            awk -F : -e '{printf $10"\n"}'\
    )"
    [ 0 == $? ] || return
    extract_key "$1" "${2,,}" "$3" "$purpose_key" "$export_dir" 'asc' "$5 key" 'pub' "${pass_base}${2^^}"
    extract_key "$1" "${2,,}" "$3" "$purpose_key" "$export_dir" 'gpg' "$5 key" 'pub' "${pass_base}${2^^}"
    extract_key "$1" "${2,,}" "$3" "$purpose_key" "$import_dir" 'asc' "$5 key" 'sec' "${pass_base}${2^^}"
    extract_key "$1" "${2,,}" "$3" "$purpose_key" "$import_dir" 'gpg' "$5 key" 'sec' "${pass_base}${2^^}"
    [ "auth" == "${5,,}" ] || return
    [[ ${2^^} == *_SSH* ]] || [[ ${2^^} == *_GIT* ]] || return
    extract_ssh_key "$1" "${2^^}" "${3,,}" "$4" 'auth'
}

store_cert_pair "$1" "$2"

