#! /usr/bin/env bash
set -o pipefail

source ./.config

auth_filter='a'
crypt_filter='e'
sign_filter='s'
ecc_filter='..25519'
rsa_filter=':23'

# Routine for error condition messages and aborting.
report_error() { # message
    printf "\nERROR: %s Aborting.\n" "$1" >&2
    exit 1
}

# Routine for reporting that there is nothing to do, for whatever reason
report_nothing() { # message
    printf "\n%s Nothing to do.\n" "$1" >&2
    exit 1
}

# Routine to convert a ring_name to a path
get_ring_path() { # ring_name
    [ -z $1 ] && \
        report_nothing "No keyring name supplied."
    ring_var="ring_${1,,}"
    [ -d "${!ring_var}" ] || \
        report_error "Invalid keyring name $1."
    printf "%s" "${!ring_var}"
}

# Routine to load cert config data
check_config_data() { # config_prefix
    [ -z $1 ] && \
        report_nothing "No config file given."
    [ -e "$config_dir/${1^^}.cfg" ] || \
        report_error "Config file for '$1' not found."
    printf "%s" "$config_dir/${1^^}.cfg"
}

# Routine to check the given keyring for the selected cert
check_prime() { # keyring_path cert_id
    find_id="${2// /}"
    test_id="$(\
        gpg \
            --homedir "$1" \
            --with-colons \
            --list-secret-keys $find_id \
        2>/dev/null \
        | grep -A 1 ^sec \
        | tail -n 1 \
        | awk -F : -e '{printf $10}'\
    )"
    [ 0 -eq $? ] || \
        report_error "Searching keyring $1 for cert id '$2' failed."
    [ "$test_id" == "$find_id" ] || \
        report_error "Searching for $find_id in keyring $1 returned $test_id. Mismatched ID's."
    printf "%s" $test_id
}

# Extract a key, or cert, from the keyring
extract_key() { # dir config target algo save_dir [('asc')|'gpg' [('key')|'cert [('pub')|'sec' [pass]]]]
    key_name="${2^^}_user"
    pfx_name="${2^^}_pfx"
    file_pfx="${!pfx_name}"
    [ -d "$5" ] || mkdir -p "$5" 2>/dev/null
    [ 0 -eq $? ] || \
        report_error "Destination path '$5' not available."
    if [ 'gpg' == "${6,,}" ]; then
        armor=''
        format='GPG'
    else
        armor='--armor'
        format='ASC'
    fi
    if [ 'cert' == "${7,,}" ]; then
        target=$3
        file_label='cert'
        note_label='certifcate'
    else
        target="$3!"
        file_label='key'
        note_label="$7"
    fi
    if [ 'sec' == "${8,,}" ]; then
        export_type='-secret-key'
        note_type='secret'
        export_label='sec'
    else
        export_type=''
        note_type='public'
        export_label='pub'
    fi
    [ -z "$9" ] && pass='' || pass="$9"
    file_note="${4^^} $note_type $note_label for ${!key_name}"
    printf "Saving %s in %s format ... " "$file_note" $format
    printf "%s" "$pass" |
    gpg \
        --homedir $1 \
        --batch \
        --yes \
        --expert \
        --pinentry-mode loopback \
        --passphrase-fd 0 \
        --output "$5/${!pfx_name}.${4,,}.$file_label.$export_label.${format,,}" \
        --comment "$file_note" $armor \
        --export$export_type $target 2>/dev/null
    [ 0 == $? ] || \
        report_error "Saving of $note in $format format failed."
    printf " DONE \n"
}

# Change the passpharse on a certificate
new_pass() {  # ring_path key_id old_pass new_pass
    checking="$(\
        printf "%s\n%s\n%s\n" "$3" "$4" "$4" \
        | gpg \
            --homedir $1 \
            --batch \
            --yes \
            --expert \
            --pinentry-mode loopback \
            --command-fd 0 --passwd "${2// /}" \
        2>/dev/null\
    )"
    [ 0 -eq $? ] || \
        report_error "Changing passphrase on ${2// /} failed."
}

# Extract public and secret, primary and sub keys to files
store_cert() { # keyring_path data_pfx target_algo
    id_name="${2^^}_${3,,}_sec"
    target_id="$(
        check_prime "$1" "${!id_name}"
    )"
    filter_name="${3,,}_filter"
    algo_filter="${!filter_name}"
    # Save the primary key to files
    store_prime "$1" "$target_id" "${2^^}" "${3,,}"
    # Need to have the subkeys stored with a different passpharse than the master
    new_pass "$1" "$target_id" "${pass_main}" "${pass_base}${2^^}"
    for purpose in sign crypt auth; do
        # Save the subkeys to files
        store_subkey
    done
    # Reverse the passpharse change
    new_pass "$1" "$target_id" "${pass_base}${2^^}" "${pass_main}"
}

# Routine to walk through the ECC and RSA pair of certs
store_cert_pair() { # ring_id data_prefix
    keyring_path="$(get_ring_path $1)"
    [ 0 -eq $? ] || exit 1
    data_file="$(check_config_data $2)"
    [ 0 -eq $? ] || exit 1
    source "$data_file"
    for target_algo in ecc rsa; do
        store_cert "$keyring_path" "${2^^}" $target_algo
    done
}

# Extract the primary key to files for storage
store_prime() { # keyring_path key_id data_pfx
    # save the primary public key
    extract_key "$1" "${3,,}" "${2// /}" "$4" "$export_dir" 'asc' 'primary key' 'pub'
    # save the full public cert
    extract_key "$1" "${3,,}" "${2// /}" "$4" "$export_dir" 'asc' 'cert' 'pub'
    # save the full secret cert
    extract_key "$1" "${3,,}" "${2// /}" "$4" "$extract_dir" 'gpg' 'cert' 'sec' "${pass_main}"
    # change the passphrase for backup files
    new_pass "$1" "${2// /}" "${pass_main}" "${prime_base}${pass_base}${3^^}"
    # save the primary secret key and full secret cert in asc and gpg formats
    extract_key "$1" "${3,,}" "${2// /}" "$4" "$import_dir" 'asc' 'primary key' 'sec' "${prime_base}${pass_base}${3^^}"
    extract_key "$1" "${3,,}" "${2// /}" "$4" "$import_dir" 'asc' 'cert' 'sec' "${prime_base}${pass_base}${3^^}"
    extract_key "$1" "${3,,}" "${2// /}" "$4" "$import_dir" 'gpg' 'primary key' 'sec' "${prime_base}${pass_base}${3^^}"
    extract_key "$1" "${3,,}" "${2// /}" "$4" "$import_dir" 'gpg' 'cert' 'sec' "${prime_base}${pass_base}${3^^}"
    # reset the passphrase from above
    new_pass "$1" "${2// /}" "${prime_base}${pass_base}${3^^}" "${pass_main}"
}

# Extract the secret and public, and possibly SSH sub keys to files
store_subkey() {
printf " IN: %s %s\n" "store_subkey" "$(printf "%s " $@)" >&2
}

store_cert_pair "$1" "$2"

